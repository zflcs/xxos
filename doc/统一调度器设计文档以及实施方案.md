### 统一调度器设计文档以及实施方案

#### 基本准则：内核进行进程调度，进程切换，进入用户态后，只有线程切换，协程只是在栈上运行的一段函数

#### 进程：资源分配的单位

- 内核从调度器中取出进程，进程切换，在发生中断、异常、系统调用时进入内核，所有进程共用同一个内核栈
- 进程的入口不再是传统的用户进程入口，而是通过 vDSO 共享给用户的一段代码，为此需要在内核切换到进程之前初始化这段代码的缺省语境，在进入到这段代码之后，完成用户进程的堆等数据结构的初始化；

#### 线程：栈的承载者

- 进入共享代码完成一系列初始化时，将用户进程 main 函数封装成协程（下文称之为 **main 协程**）并添加到 EXECUTOR 中，之后通过 loop 循环不断的取出协程执行，进程初始化之后的默认栈是由共享代码在占用

- 初始情况下，EXECUTOR 中只存在 main 协程，并且其内部是一段较长的同步代码，如若在 main 协程中创建了新的协程，则会调用共享代码中的 add_coroutine 函数将协程添加进 EXECUTOR 中，会出现下列两种情况：

  - main 协程中执行了一些阻塞的操作，此时如果直接在默认的栈上执行，则会将整个进程会阻塞
  - main 协程执行没有阻塞，EXECUTOR 会取出新添加的协程执行

  因此，对于每个添加进 EXECUTOR 的协程，需要创建额外的栈来执行，不能直接在进程默认使用的栈上运行。在这种情况下，即使是执行 main 协程阻塞了（需要内核的配合），并不会将整个进程阻塞，通过用户态的线程控制（例如 yield_thread）切换到共享代码部分，再创建新的栈，从 EXECUTOR 中取出协程执行，这里是用户态的线程切换

#### 协程：调度的基本单位





#### 多核支持

- 多核初始化，每个核都有自己的一套寄存器，共用相同的内核映像，核的初始化即是将寄存器初始化
  - 主核启动之后，初始化pritlib、syscall、页机制、中断机制、通过HSM启动其他核，其他核进行初始化一般就是初始化内核根页表、中断机制
  - 所有的核共用一个进程调度队列，共享代码的数量应该与核的数量相同，每个共享代码的虚拟页号不同，这个地方和异界传送门相同，（异界传送门不是跳板页，跳板页只需要一份，而异界传送门每个核各一份），因此需要准备一个异界传送门以及共享代码池
- 每个核拥有的资源：异界传送门以及共享代码，但并不是固定的关系，核执行哪个进程，其使用的异界传送门和共享代码就是进程初始化时确定的异界传送门和共享代码
  - 共享代码是不是可以像异界传送门一样，设计成一个对象呢？？？
- 进程的初始化需要分为两个阶段
  - 第一阶段初始化，主要是初始化地址空间
  - 第二阶段初始化是在进程被调度需要运行之前，由内核初始化，根据在哪个核上被运行来初始化异界传送门以及共享代码的映射关系，初始化对应核的共享代码的缺省语境

- 进程调度会有两种情况：（一般是一个进程一个核，如果最后剩下的任务数量小于核数量时，一个任务可以分配多个核）
  - 一个进程只分配了一个核：进程控制块第一阶段初始化之后，被调度运行前，初始化进程控制块中的共享代码指针以及异界传送门指针，在调度时直接跳转到对应的共享代码执行
  - 一个进程分配了多个核：此时已经有一个核在执行这个进程，再次分配核给这个进程，这个时候其他的核还是会跳转到主核的共享代码部分，在共享代码中会通过同步互斥机制使得多核能够正常运行



#### 用户态线程
- 执行 run 函数，从 EXECUTOR 中取出协程，创建线程执行，保存共享代码的上下文到栈中，然后从 Thread 的 context 中回复上下文
