### 统一调度器设计文档以及实施方案

#### 基本准则：内核进行进程调度，进程切换，进入用户态后，只有线程切换，协程只是在栈上运行的一段函数

#### 进程：资源分配的单位

- 内核从调度器中取出进程，进程切换，在发生中断、异常、系统调用时进入内核，所有进程共用同一个内核栈
- 进程的入口不再是传统的用户进程入口，而是通过 vDSO 共享给用户的一段代码，为此需要在内核切换到进程之前初始化这段代码的缺省语境，在进入到这段代码之后，完成用户进程的堆等数据结构的初始化；

#### 线程：栈的承载者

- 进入共享代码完成一系列初始化时，将用户进程 main 函数封装成协程（下文称之为 **main 协程**）并添加到 EXECUTOR 中，之后通过 loop 循环不断的取出协程执行，进程初始化之后的默认栈是由共享代码在占用

- 初始情况下，EXECUTOR 中只存在 main 协程，并且其内部是一段较长的同步代码，如若在 main 协程中创建了新的协程，则会调用共享代码中的 add_coroutine 函数将协程添加进 EXECUTOR 中，会出现下列两种情况：

  - main 协程中执行了一些阻塞的操作，此时如果直接在默认的栈上执行，则会将整个进程会阻塞
  - main 协程执行没有阻塞，EXECUTOR 会取出新添加的协程执行

  因此，对于每个添加进 EXECUTOR 的协程，需要创建额外的栈来执行，不能直接在进程默认使用的栈上运行。在这种情况下，即使是执行 main 协程阻塞了（需要内核的配合），并不会将整个进程阻塞，通过用户态的线程控制（例如 yield_thread）切换到共享代码部分，再创建新的栈，从 EXECUTOR 中取出协程执行，这里是用户态的线程切换

#### 协程：调度的基本单位

