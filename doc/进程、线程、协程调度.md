# 进程、线程、协程调度设计方案

### 内核调度进程
* 内核选到下一个需要调度的进程之后，会先进入定义好的调度主线程
* 调度主线程再来调度线程或者协程
* executor 这个数据结构应该在用户态声明，而不是在进程 pcb 中由内核进行管理，executor 由主线程来创建，内核的 pcb 中只保存最高的优先级这个字段
* 在创建进程的时候，通过检查符号表，判断是否支持协程，如果支持协程，则需要创建主线程，链接调度代码
* 进程的优先级则最开始初始化成最大的，然后每次进来系统调用就传递有一个优先级吧，这样子就可以维护了
* 只在用户态创建线程，不进入内核
* 内核中只负责管理用户进程的主线程，这个线程永远不会被阻塞
* 当用户态的其他线程需要进入内核时，可以直接用 其他线程的 LocalContext 来替换主线程的 LocalContext，不需要由主线程负责，这一切不会不阻塞
* 从内核回到用户态的线程之后，继续执行，线程执行完之后，就回到主线程继续调度下一个线程，这个地方逻辑应该是合理的吧
* 按照这种思路，线程的创建只需要在用户态即可，内核也不会阻塞
* 面临的首要问题是，创建了主线程之后，和实际的用户代码无关，怎么再创建出真正的代码线程呢
    * 在内核创建主线程时，就把段给添加到地址空间中，然后只需要通过参数传递的方式，把代码入口以及栈传递给主线程
    * 主线程先创建这个执行代码，再来



### 实施步骤
* 考虑主线程使用 GlOBAL 来分配数据，怎么将 GLOBAL 的对象当作参数传递进去呢
    * 将 HEAP 的可变引用传参传进去，然后重新实现 GlobalAlloc 特性
    * 怎么在进程初始化时，将 HEAP 的参数传递进去呢
        * ~~扫描进程的 elf 文件，然后查到 HEAP 的位置，然后再当作参数传递给这个主线程（通过链接脚本，将 HEAP 放在 data 数据段的首部，省略了扫描符号表的过程~~
    * 但是这样会带来新的问题，一旦发生了进程切换，那么这个 HEAP 的参数会发生变化，怎么样保证这个是正确的呢
        * 一旦需要切换进程，在切换到新的进程时，先执行 init 函数，替换掉对应的指针，把 HEAP 的指针保存在 pcb 里面
    * 理论上可行吗？？？
    * 如果是多核的话，还是需要为每个核准备一个主线程的代码
* 先创建主线程，然后在主线程中创建一个真正的执行线程
    * 这里涉及先后顺序的问题，HEAP 需要根据 MEMORY 来初始化
    * 主线程使用堆需要根据 HEAP 的指针初始化
    * 把 HEAP 和 MEMORY 的位置调整一下，让 MEMORY 紧跟在 HEAP 之后，因此在内核进行初始化时，只需要传递 HEAP 的指针

    

* 先写主线程的代码
    * 主线程需要定义在一个特定的区域，用来共享
    * init 函数，初始化堆
    * user_thread_main 函数中不断地循环，从自己的 executor 中找到线程或者协程来执行、也可以创建线程、协程之类的

* 主线程目前是通过函数调用执行真正的代码，接下来应该通过创建线程来执行
    * 在创建线程之后，关于一些线程控制的系统调用应该要改成用户态的
        * yield_thread 当前线程让出 cpu
        * 直接把当前的真正的代码当作异步的，直接创建协程？？？

* 将 main 也写成 async 不行，编译链接时找不到 main

关于进程进入内核读 pipe 阻塞进行切换，这部分流程让内核协程来处理

现在 EXECUTOR 可以支持优先级了
接下来考虑添加线程，实现协程抢占，并且添加用户态线程控制函数


