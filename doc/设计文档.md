## 任务设计

进程和线程不做区分，内核的调度队列中不区分线程和协程，都在同一个队列中进行调度

## 陷入设计

- 上下文保存在控制流所对应的栈的顶部

- 上下文的结构如下，主要是 sp 需要保存在栈顶

  ```rust
  #[repr(C)]
  #[allow(missing_docs)]
  pub struct FlowContext {
    pub sp: usize,      // 0，
    pub ra: usize,      // 1..
    pub t: [usize; 7],  // 2..
    pub a: [usize; 8],  // 9..
    pub s: [usize; 12], // 17..
    pub gp: usize,      // 29..
    pub tp: usize,      // 30..
    pub pc: usize,      // 31..
  }
  ```

  基于上述两点，可以把用户和内核栈映射到固定的虚拟地址，在进入到 stvec 寄存器指向的 fast-handler 函数时，保存上下文到用户态栈顶的上下文中

  - 这个过程不需要切换 sp 寄存器中的值，sscratch 寄存器可以用于存放其他有用的信息
  - fast-handler 直接复用用户态的栈
  - 注意：需要特别处理恶意用户程序，写了不能访问的 sp，在进入到 s 态之后会触发 s 态的异常，这属于缺页异常，但是需要直接杀死这个恶意进程；同时，返回用户态时，需要对栈下面的数据擦除（是否擦除还需要考虑）

  按照这种方式，所有的控制流只会有一个栈，同时也可以实现内核快速路径（内核快速路径可能需要和 vdso 结合起来）
  内核应该当作一个进程，循环处理中断和异常

## 地址空间切换

地址空间切换和陷入密切相关

fast-handler 函数：发生中断/异常后，跳转到这里，接下来保存一部分寄存器，match 语句处理完部分的异常或中断，（这个阶段还是在用户进程地址空间），根据返回的结果，若处理完成，则返回用户态；若不能处理的中断/异常，则进行进程切换，切换到内核进程，需要切换地址空间和恢复内核上下文。

若需要进程切换，则需要把剩下的寄存器保存完。这时整体的上下文保存结束，之后切换地址空间，由于上下文都被保存在各自的栈中，因此需要先切换地址空间，才可以恢复内核进程的上下文。内核的地址空间不能是固定的，因此可以将内核地址空间事先保存在 sscratch 寄存器中，之后再从指定的栈的虚拟地址读出上下文，从而切换到内核进程。

从 s 态进入到 u 态时，无论是从快速路径返回到用户态的，还是直接从内核进程切换到用户进程，这部分代码都需要保存在公共地址空间。进程切换函数的参数为 satp，satp 寄存器不需要保存在上下文中，而是保存在进程控制块中，这样不需要额外进行地址转换。



## 实现过程中遇到的问题

### riscv 寻址模式：

> 立即数寻址
>
> 寄存器寻址
>
> 基址寻址：寄存器的偏移用立即数表示，但是只能是 12位
>
> pc 寻址

没有直接寻址模式，如果直接对固定的栈顶位置进行内存操作，如果是 x86 则可以直接寻址，因此这个栈的地址可以是任意的，但是 riscv 没有直接寻址，并且这种设计思路不能使用 sscratch 寄存器，因此把 立即数寻址、寄存器寻址、pc 寻址全部排除，只剩下基址寻址，并且基址寻址只能使用 x0 寄存器，那么可以考虑使用有符号的立即数，0x0 - 1 = 0xffffffffffffffff，通过这种方式进行寻址，因此直接限制了栈顶的虚拟地址为 0xffffffffffffffff

### 栈虚拟地址单独映射
栈映射到高位虚拟地址，在开启分页之后，会出现异常，解决方案是，同时建立 stack 的对等映射和高位虚拟地址映射，之后移动 sp 指针到高位地址，再取消对等映射，如果不这么做，sp 指针一直是对等映射，在保存上下文的时候，恢复上下文是读取的高位虚拟地址，但是 sp 又指向对等映射的地址，可以不取消对等映射来保证正常运行，但是强迫症患者，喜欢保证这个一致